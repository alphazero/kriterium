// Licensed to Elasticsearch under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// package errors provides the facility for definition of typed
// errors.
package errors

import (
	"fmt"
)

// Generated error prefix.
const prefix = "error: " // REVU: consider making this public

// compute this once.
const prefixlen = len(prefix)

// TypedError is an error generator function type. Users of the package typically do
// not need to refer to this type explicitly. It is exported to support
// the idiom of defining errors with literal struct types, as shown
// below:
//
//    var ERR = struct {
//        IOError, IllegalArgument,  errors.TypedError
//    }{
//        IOError:          errors.New("IOError"),
//        IllegalArgument:  errors.New("IllegalArgument"),
//    }
//    ...
//
//    func woof(n int) error {
//        if n < 0 {
//            return ERR.IllegalArgument("n is negative")
//        }
//        ...
//    }
//
type TypedError func(args ...interface{}) error

// Returns a new error generator function for the given error code.
//
// The generator function takes 0 or more generic arguments. Arguments
// are appended to the errcode parameter per fmt.Sprint().
//
// If no args are provided, the generator function simply returns an error
// using the errcode provided and omits the ':' decoration after the errcode.
//
// Usage examples:
//
//    import "escargo/errors"
//    ...
//
//    var ErrWot   = errors.New("Something went wrong")
//    var ErrMyBad = errors.New("MyBad")
//    var ErrIO    = errors.New("IO Error")
//    ...
//
//    // ex: general error message with no additional details.
//    // always returns the error "ERR - Something went wrong"
//    func confusion() error {
//        if true {
//            return ErrWot()
//        }
//    }
//
//    // ex: general error code with instance specific parameters
//    // always returns the error "ERR - MyBad: oops, did it again :("
//    func errorProne() error {
//        if true {
//            return ErrMyBad("oops, did it again :(")
//        }
//    }
//
//    // ex: general error with underlying specific cause
//    // assuming that 'badarg' = "nosuchfile.txt"
//    // always returns the error "ERR - IOError: open nosuchfile.txt: no such file or directory"
//    func garbageIn(badarg string) error {
//        data, e := ioutils.ReadFile(badarg)
//        if e != nil {
//            return ErrIO(e)
//        }
//    }
func New(errcode string) TypedError {
	return func(args ...interface{}) error {
		decoration := ""
		if len(args) > 0 {
			decoration = ":"
		}
		errfmt := []interface{}{fmt.Sprintf("%s%s%s", prefix, errcode, decoration)}
		args0 := append(errfmt, args...)
		return fmt.Errorf("%s", fmt.Sprint(args0...))
	}
}

// Function tests whether the input arg is an instance of an error
// generated by this TypedError.
//
// Usage example:
//
//    import "escargo/errors"
//    ...
//
//    var IllegalArgumentError = errors.New("IllegalArgument")
//    var IOError              = errors.New("IOError")
//    ...
//
//    // Returns file content
//    // If input arg is zerovalue, returns IllegalArgumentError
//    // If file read fails, returns IOError
//    func readFile(filename string) ([]byte, error) {
//        if filename == "" {
//           return nil, IllegalArgumentError("filename is empty")
//        }
//        data, e := ioutil.ReadFile(path)
//        if e != nil {
//            return nil, IOError(e)
//        }
//        return data, nil
//    }
//
//    // At the call site, we can check for error type using
//    // TypedError.Instance, as shown below.
//    func example() {
//        var filename = "nosuchfile.txt"
//        data, e := readFile(filename)
//        switch {
//        case IllegalArgumentError.Instance(e):
//           log.Fatalf(e)
//        case IOError.Instance(e):
//           log.Fatalf(e)
//        }
//        ...
//    }
func (fn TypedError) Instance(e error) bool {
	errcode := fn.Code()
	codelen := len(errcode)
	e0 := e.Error()
	if len(e0) < codelen {
		return false
	}
	return errcode == e0[prefixlen:codelen+prefixlen]
}

// Returns the error code of this TypeError.
func (fn TypedError) Code() string {
	return fn().Error()[prefixlen:]
}
